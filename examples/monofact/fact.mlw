module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = {  }
  
  type state = private { mutable ghost alloct : M.t reftype }
    invariant { not (M.mem null alloct) }
    by { alloct = (().M.create) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) = forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference. ((Rgn.mem p r) -> ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference. ((M.mem p pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference. ((M.mem p pre.alloct) -> ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn)
end

module I
  use prelude.Prelude
  use State
  
  val fact (s: state) (n: int) : int
    requires { n >= 0 }
end

module F
  use prelude.Prelude
  use State
  use I
  
  let fact (s : state) (n : int) : int
    requires { n >= 0 }
    diverges
  = label INIT in
      let result = ref 0 in
      let n = ref n in
      let i = ref 0 in
      let r = ref 0 in
      (i := ([@expl:i := 0] 0));
      (r := ([@expl:r := 1] 1));
      while ((! i) < (! n)) do
        invariant { alloc_does_not_shrink (old s) s }
        (i := ([@expl:i := i + 1] ((! i) + 1)));
        (r := ([@expl:r := r * i] ((! r) * (! i))))
      done;
      (result := ([@expl:result := r] (! r)));
      (! result)
end

module FREL
  use prelude.Prelude
  use State
  use F
  
  let fact (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_n : int) (r_n : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { l_n >= r_n }
    requires { ((l_n >= 0) /\ (r_n >= 0)) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> l_result >= r_result
              end }
    diverges
  = label INIT in
      let l_result = ref 0 in
      let r_result = ref 0 in
      let l_n = ref l_n in
      let r_n = ref r_n in
      let l_i = ref 0 in
      let r_i = ref 0 in
      let l_r = ref 0 in
      let r_r = ref 0 in
      ((l_i := ([@expl:i := 0] 0)); (r_i := ([@expl:i := 0] 0)));
      ((l_r := ([@expl:r := 1] 1)); (r_r := ([@expl:r := 1] 1)));
      while ((! l_i) < (! l_n))  || ((! r_i) < (! r_n)) do
        invariant { okRefperm l_s r_s pi }
        invariant { (((0 <= (! l_i)) /\ ((! l_i) <= (! l_n))) /\ ((0 <= (! r_i)) /\ ((! r_i) <= (! r_n)))) }
        invariant { (! l_i) >= (! r_i) }
        invariant { ((! r_i) < (! r_n)) -> ((! l_i) = (! r_i)) }
        invariant { ((! l_r) >= (! r_r)) /\ (((! l_r) >= 1) /\ ((! r_r) >= 1)) }
        invariant {
          [@expl:alignment condition]
          ((((! l_i) < (! l_n)) /\ ((! r_i) = (! r_n))) \/
             ((((! r_i) < (! r_n)) /\ false) \/
                ((((! l_i) < (! l_n)) /\ ((! r_i) < (! r_n))) \/ ((not ((! l_i) < (! l_n))) /\ (not ((! r_i) < (! r_n))))))) }
        if ([@expl:Left step] (((! l_i) < (! l_n))  && ((! r_i) = (! r_n)))) then
          ((l_i := ([@expl:i := i + 1] ((! l_i) + 1))); (l_r := ([@expl:r := r * i] ((! l_r) * (! l_i)))))
        else
          (if ([@expl:Right step] (((! r_i) < (! r_n))  && false)) then
             ((r_i := ([@expl:i := i + 1] ((! r_i) + 1))); (r_r := ([@expl:r := r * i] ((! r_r) * (! r_i)))))
           else
             (((l_i := ([@expl:i := i + 1] ((! l_i) + 1))); (r_i := ([@expl:i := i + 1] ((! r_i) + 1))));
              (l_r := ([@expl:r := r * i] ((! l_r) * (! l_i))));
              (r_r := ([@expl:r := r * i] ((! r_r) * (! r_i))))))
      done;
      (l_result := ([@expl:result := r] (! l_r)));
      (r_result := ([@expl:result := r] (! r_r)));
      ((! l_result), (! r_result))
end

module FREL_biinterface
  use prelude.Prelude
  use State
  use F
  
  val fact (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_n: int) (r_n: int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { l_n >= r_n }
    requires { ((l_n >= 0) /\ (r_n >= 0)) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> l_result >= r_result
              end }
end

module MAIN
  use prelude.Prelude
  use State
end

